<h1><a href="https://google.com" target="blank"> Recruiter's Gear Documentation</a></h1>
<Table>
  <thead>
    <tr>
      <th>Aspect</th>
      <th>Software Documentation</th>
      <th>Project Documentation</th>
      <th>User Documentation</th>
      <th>Developer Documentation</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><b>Purpose</b></td>
      <td><a href = " "><a/></td>
      <td><a href = " "><a/></td>
      <td><a href = " "><a/></td>
      <td><a href = " "><a/></td>
    </tr>
    <tr>
      <td><b>Target Audience</b></td>
      <td><a href = " " style="text-decoration: none;">Back-End: Code Structure, <a/><a href = " ">Front-End: Code Structure<a/></td>
      <td><a href = " ">Back-End: Code Structure, <a/></td>
      <td><a href = " "><a/></td>
      <td><a href = " ">Back-End: Code Structure, <a/><a href = " ">Front-End: Code Structure, <a/><a href = " "><a/><a href = " ">Front-End: API CRUD Operation, <a/><a href = " ">SocketIO, <a/><a href = " ">Back-End: CRUD Operation, <a/><a href = " ">Front-End: CRUD Operation<a/></td>
    </tr>
    <tr>
      <td><b>Level of Details</b></td>
      <td><a href = " ">Code Convention<a/></td>
      <td><a href = " ">Front-End: Development workflow, <a/><a href = " ">Front-End: Development workflow<a/></td>
      <td><a href = " ">Back-End: Flow Chart, <a/><a href = " ">Front-End: Logic Flow Chart, <a/><a href = " ">Back-End: Logic Flow Chart, <a/><a href = " ">Front-End: Development workflow<a/></td>
      <td><a href = " ">Code Convention, <a/><a href = " ">Front-End: Development workflow<a/></td>
    </tr>
    <tr>
      <td><b>Focus Area</b></td>
      <td><a href = " ">Error Handling<a/></td>
      <td><a href = " "><a/></td>
      <td><a href = " "><a/></td>
      <td><a href = " ">Error Handling<a/></td>
    </tr>
    <tr>
      <td><b>Examples</b></td>
      <td><a href = " ">Front-End: App.js Details<a/></td>
      <td><a href = " "><a/></td>
      <td><a href = " "><a/></td>
      <td><a href = " ">Back-End: How to Install?, <a/><a href " ">Back-End: How to Run?, </a><a href = " ">Front-End: How to Install?, <a/><a href " ">Front-End: How to Run?, </a><a href = " ">Front-End: App.js Details<a/></td>
    </tr>
    <tr>
      <td><b>Format</b></td>
      <td><a href = " ">Back-End: End-Points, <a/><a href = " ">Types of Controller, <a/><a href = " ">Back-End: Project Structure, <a/><a href = " ">Front-End: Project Structure<a/></td>
      <td><a href = " ">Back-End: End-Points, <a/><a href = " ">Types of Controllers, <a/><a href = " ">Back-End: Project Structure, <a/><a href = " ">Front-End: Project Structure<a/></td>
      <td><a href = " ">Back-End: End-Points, <a/><a href = " "><a/></td>
      <td><a href = " ">Back-End: End-Points, <a/><a href = " ">Types of Controllers, <a/><a href = " ">Back-End: Project Structure, <a/><a href = " ">Front-End: Project Structure<a/></td>
    </tr>
    <tr>
      <td><b>Requirements</b></td>
      <td><a href = " ">ENV Variable, <a/><a href = " ">Front-End: Dependencies & Versions, <a/><a href = " ">Back-End: Dependencies & Versions, <a/><a href = " ">SocketIO<a/><a href = " ">Back-End: application.properties, <a/><a href = " ">Fron-End: pacakge.json file, <a/><a href = " ">Front-End: npm libraries<a/></td>
      <td><a href = " "><a/></td>
      <td><a href = " "><a/></td>
      <td><a href = " ">Technologies: Front-End, Back-End, Database, Cloud, Authentication, Version Control, Servers, <a/><a href = " ">ENV Variable, <a/><a href = " "><a/><a href = " ">Front-End: Dependencies & Versions, <a/><a href = " ">Back-End: Dependencies & Versions, <a/><a href = " ">SocketIO Server, <a/><a href = " ">Back-End: application.properties, <a/><a href = " ">Front-End: pacakge.json file, <a/><a href = " ">Front-End: npm libraries, <a/><a href = " ">Front-End: CSS, Tailwind<a/></td>
    </tr>
  </tbody>
</Table>

### **Technologies**

#### **1. Front-End: React + Vite**

- **1.1. React** is one of the most popular and powerful JavaScript libraries for building user interfaces, especially Single Page Applications (SPAs). It provides a component-based architecture, promoting reusability, maintainability, and scalability.
- **1.2. Vite** is a modern, fast build tool optimized for speed and performance. Unlike older bundlers like Webpack, Vite uses native ES modules in the development environment, resulting in extremely fast hot module replacement (HMR) and faster builds. It's designed to be simple, minimal, and super fast, making it ideal for modern React projects.

#### **1.3. Why it's good:**
- **1.3.1. Developer Experience**: Vite's lightning-fast build times and React's component model enhance productivity, making development smoother.
- **1.3.2. Performance**: Vite's on-demand code loading helps keep initial load times fast, improving the user experience.

---

#### **2. Back-End: Java; Framework: Spring Boot**

- **2.1. Java** is a time-tested, reliable, and highly scalable programming language with a vast ecosystem and community. It's ideal for building large-scale, enterprise-level applications due to its stability, security features, and performance.
- **2.2. Spring Boot** is a popular Java framework that simplifies the setup and configuration of Spring applications. It offers out-of-the-box solutions for many common problems, such as REST API development, database connections, and security. It follows the principles of convention over configuration, allowing developers to focus on business logic rather than boilerplate code.

#### **2.3. Why it's good:**
- **2.3.1. Scalability**: Java with Spring Boot is perfect for building scalable, high-performance back-end systems. It easily integrates with various databases and third-party services, and Spring Boot's microservices support allows for building complex applications.
- **2.3.2. Security**: Spring Boot has built-in support for security features, making it easier to protect applications.
- **2.3.3. Ease of Use**: Spring Boot’s extensive set of pre-configured templates and auto-configuration features makes it quicker to set up and develop applications.

---

#### **3. Database: MySQL**

- **3.1. MySQL** is one of the most popular relational database management systems (RDBMS) in the world. Known for its performance, reliability, and ease of use, MySQL supports ACID-compliant transactions, ensuring data consistency, durability, and integrity — all critical for modern web applications.

#### **3.2. Why it's good:**
- **3.2.1. Mature and Reliable**: MySQL is battle-tested in production environments for years and is often the go-to database for various applications, from small startups to large enterprises.
- **3.2.2. Open-source**: As an open-source database, MySQL offers a robust set of features without the licensing costs of commercial databases.
- **3.2.3. Good Integration**: MySQL integrates seamlessly with Spring Boot (via Spring Data JPA, for example), streamlining development.

---

#### **4. Cloud: Ubuntu**

- **4.1. Ubuntu** is a popular open-source operating system, widely used for cloud deployments. It is known for its ease of use, regular updates, and large community support. Ubuntu is often the preferred choice for cloud servers on platforms like AWS, Azure, and DigitalOcean due to its compatibility with most cloud providers.

#### **4.2. Why it's good:**
- **4.2.1. Open Source and Free**: Ubuntu is free to use, making it cost-effective.
- **4.2.2. Stability and Security**: Ubuntu provides regular updates and strong security features, making it a solid choice for production environments.
- **4.2.3. Compatibility**: Most cloud environments (including AWS EC2, Google Cloud, etc.) support Ubuntu, and it’s optimized for cloud deployments.

---

#### **5. Authentication: OAuth2**

- **5.1. OAuth2** is the industry standard for authorization and authentication. It allows users to securely authenticate to applications without exposing their credentials, relying instead on tokens (such as access and refresh tokens). OAuth2 can enable single sign-on (SSO) and third-party authentication, like signing in with Google or Facebook.

#### **5.2. Why it's good:**
- **5.2.1. Security**: OAuth2 is widely accepted, ensuring secure, token-based access management without needing to store passwords directly.
- **5.2.2. Flexibility**: It can be integrated with many identity providers, enabling flexibility and easier management of user access across platforms.
- **5.2.3. Single Sign-On (SSO)**: OAuth2 enables SSO, allowing users to authenticate once and use multiple apps without needing to log in repeatedly.

---

#### **6. Version Control: Git**

- **6.1. Git** is the most widely used version control system in the world. It enables teams to manage code changes efficiently, track history, and collaborate on projects.

#### **6.2. Why it's good:**
- **6.2.1. Collaboration**: Git facilitates easy collaboration by allowing branching, merging, and versioning.
- **6.2.2. Version History**: Git tracks all changes to the codebase, making it easy to roll back to any previous version.
- **6.2.3. Distributed Nature**: Git's distributed model enables every developer to have their own local copy of the repository, which improves speed and offline work.


## Topic: How to Install / Run?

### 1. JDK

#### 1.1: What is JDK?

**JDK 17** (Java Development Kit 17) is a major release of the Java platform, released in September 2021 by Oracle. It is a **Long-Term Support (LTS)** version, meaning it will receive extended support and updates for several years, making it a preferred choice for many developers and enterprises for building production-ready applications.

The **JDK** is a software development kit that provides all the tools required for Java development, including:

- **Java Runtime Environment (JRE)** – the environment in which Java applications run.
- **Java Compiler** – compiles Java code into bytecode for the JVM.
- **Java Virtual Machine (JVM)** – the engine that executes Java bytecode.
- **Java Libraries** – standard classes and APIs that Java developers use for common tasks.
- **Development, Debugging, and Monitoring Tools** – tools like `javac`, `jdb`, and `jconsole` for building, testing, and monitoring Java applications.

---

#### 1.2: Why Do We Use JDK 17?

#### 1.2.1: **Long-Term Support (LTS)**

JDK 17 is an **LTS version**, which means it will receive updates, bug fixes, and security patches for **several years** (until at least 2029). LTS versions are preferred in **production environments** as they ensure stability and long-term support.

#### 1.2.2: **New Features & Enhancements**

JDK 17 brings many new features, enhancements, and improvements to the Java platform, which can improve developer productivity and system performance. These include features like:

- **Pattern Matching** (for switch expressions and `instanceof` operations).
- **Sealed Classes** (a new feature to restrict class inheritance).
- **Strong encapsulation of JDK internals** (improving security).
- **Improved garbage collection** (with new garbage collectors, like the G1 Garbage Collector).
- **Deprecation and removal of outdated APIs** (to streamline and modernize the platform).

#### 1.2.3: **Performance Improvements**

JDK 17 includes performance improvements, such as better garbage collection, improved JVM optimizations, and better support for modern hardware architectures, leading to faster and more efficient applications.

#### 1.2.4: **Security Updates**

With each new version, Oracle addresses known security vulnerabilities and enhances the security of Java applications. JDK 17 comes with enhanced security features, such as support for the latest encryption standards.

#### 1.2.5: **Compatibility**

JDK 17 ensures backward compatibility with older Java versions, ensuring that most existing Java applications can run without issues. However, it is always recommended to test your code when upgrading.

#### 1.2.6: **Deprecations and Removals**

Some older and less-used features or APIs are removed or deprecated, helping to keep the platform lean and modern.

---

#### 1.3: Advantages of JDK 17?

#### 1.3.1: **LTS Support**

As an LTS release, JDK 17 will be supported for several years (until 2029), making it suitable for long-term projects and production environments.

#### 1.3.2: **Improved Performance**

Enhancements like better garbage collection and performance optimizations improve the speed and efficiency of Java applications.

#### 1.3.3: **New Language Features**

- **Pattern Matching** for `switch`: Simplifies code and makes it more concise and readable.
- **Sealed Classes**: Provides more control over class inheritance, leading to better maintainability and security.

#### 1.3.4: **Security**

Improved security features ensure that your applications are less susceptible to vulnerabilities. Additionally, Oracle continuously addresses security threats by releasing regular updates.

#### 1.3.5: **Modernization of the Java Platform**

The removal of deprecated or outdated features streamlines the platform and encourages the use of modern practices.

#### 1.3.6: **Better Garbage Collection**

JDK 17 has optimizations in garbage collection (like the G1 garbage collector), reducing memory overhead and increasing application throughput.

#### 1.3.7: **Support for Modern Development**

JDK 17 is aligned with modern software development practices and tools, including enhanced support for microservices, cloud-native apps, and containerization (e.g., Docker, Kubernetes).


#### 1.4: How to Install JDK 17?

#### Step 1: Download JDK 17

1. Visit the official Oracle website or OpenJDK website for downloading JDK 17:
   - **Oracle JDK 17**: [Oracle Downloads](https://www.oracle.com/java/technologies/javase-jdk17-downloads.html)
   - **OpenJDK 17** (Open source version): [OpenJDK Downloads](https://openjdk.java.net/projects/jdk/17/)

2. Choose the appropriate version based on your operating system (Windows, macOS, or Linux). You can download either the Oracle JDK (commercial version) or OpenJDK (open-source, free to use).

3. For Windows, choose the `.exe` file for easy installation. For macOS or Linux, choose the `.dmg` or `.tar.gz` file.

---

#### Step 2: Install JDK 17

#### For Windows:

1. After downloading the `.exe` file, double-click it to begin the installation process.
2. Follow the installation wizard, and make note of the installation directory (usually `C:\Program Files\Java\jdk-17`).
3. Once the installation is complete, you can verify the installation by opening a **Command Prompt** and running:

   ```bash
   java -version

It should show something like: 

Copy: 
```java
java version "17.0.1" 2021-10-19 LTS 

Java(TM) SE Runtime Environment (build 17.0.1+12-39) 

Java HotSpot(TM) 64-Bit Server VM (build 17.0.1+12-39, mixed mode) 
```
#### For macOS:

1. Double-click the downloaded `.dmg` file to mount it and follow the instructions to install JDK 17.
2. After installation, verify by running the following command in the terminal:

   ```bash
   java -version
#### For Linux:

1. For **Ubuntu/Debian-based** distributions, you can use `apt` to install JDK 17:

   ```bash
   sudo apt update
   sudo apt install openjdk-17-jdk
   ```
2. For **Red Hat/CentOS-based** distributions, you can use `yum` or `dnf`:

   ```bash
   sudo dnf install java-17-openjdk
   ```
3. After installation, verify it by running:

   ```bash
   java -version
   ```
# How to Set the Path of the Environment Variable?

#### For Windows:

1. **Find the JDK installation path** (usually `C:\Program Files\Java\jdk-17`).
2. **Set JAVA_HOME**:
   a. Right-click on **This PC** or **Computer** and select **Properties**.
   b. Click on **Advanced system settings** and then click **Environment Variables**.
   c. Under **System variables**, click **New** and add the following:
      - **Variable name**: `JAVA_HOME`
      - **Variable value**: `C:\Program Files\Java\jdk-17` (or the path where JDK 17 is installed).
3. **Update the PATH variable**:
   a. In the **Environment Variables** window, select the **Path** variable under **System variables**, and click **Edit**.
   b. Click **New** and add the following:
      - `C:\Program Files\Java\jdk-17\bin`
4. **Verify**:
   a. Open **Command Prompt** and run:
      ```bash
      java -version
      ```
      It should display the correct version.

---

#### For macOS/Linux:

1. Open a terminal.
2. **Set JAVA_HOME** by adding it to your shell profile:
   - For **Bash** (`.bash_profile` or `.bashrc`):
     ```bash
     export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk-17.jdk/Contents/Home  # For macOS
     export JAVA_HOME=/usr/lib/jvm/java-17-openjdk  # For Linux
     ```
   - For **Zsh** (`.zshrc`):
     ```bash
     export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk-17.jdk/Contents/Home  # For macOS
     export JAVA_HOME=/usr/lib/jvm/java-17-openjdk  # For Linux
     ```
3. **Add the bin directory to the PATH**:
   ```bash
   export PATH=$JAVA_HOME/bin:$PATH
 4. Reload the profile to apply the changes:
   ```bash
   source ~/.bash_profile  # For Bash
   source ~/.zshrc         # For Zsh
```
 5. **Verify**: Run the following command to confirm the JDK installation:
   ```bash
   java -version
```

#### Conclusion

- **JDK 17** is a major and stable version of Java, ideal for building modern Java applications with improvements in performance, security, and language features.
- It is an **LTS release**, making it a safe and reliable option for long-term projects.
- Installation involves downloading the JDK, installing it, and configuring environment variables to ensure that Java commands (`java`, `javac`) work from anywhere in the terminal or command prompt.

JDK 17 offers a good balance of new features, performance improvements, and long-term stability, making it a solid choice for developers.

---

### 2. Spring Initializr

#### **2. What is Spring Initializr?**

**Spring Initializr** is an online tool that simplifies the creation of new **Spring Boot** projects by generating a basic scaffold with minimal configuration. It provides developers with a quick way to bootstrap a Spring-based application, offering options like project metadata, dependencies, and build tool configurations.

The generated project includes the necessary configurations for the selected build system (either **Maven** or **Gradle**), and it can be opened directly in an Integrated Development Environment (IDE) like IntelliJ IDEA or Eclipse. This allows developers to start building their Spring Boot applications immediately, without having to worry about project setup and configurations.

---

#### **2.1. How to Access Spring Initializr**

You can use **Spring Initializr** in two main ways:

#### **2.1.1. Via the Web Interface**
   - Open your browser and visit [https://start.spring.io](https://start.spring.io).
   - This is the main interface where you can configure and generate a Spring Boot project.

#### **2.1.2. Via Integrated Development Environments (IDEs)**
   - Many popular IDEs, such as **IntelliJ IDEA**, **Eclipse**, and **Visual Studio Code**, provide built-in support for Spring Initializr, making it even easier to generate Spring Boot projects directly from your IDE.

---

#### **2.2. Creating a New Spring Boot Project**

#### **2.2.1. Steps to create a Spring Boot project:**

1. Open the Spring Initializr web page at [https://start.spring.io](https://start.spring.io).
2. Choose the following configuration options:
    - **2.2.2. Project**: Choose between **Maven Project** or **Gradle Project** as your build tool.
    - **2.2.3. Language**: Select **Java**, **Kotlin**, or **Groovy** based on your preference.
    - **2.2.4. Spring Boot Version**: The current stable version will be selected by default.
    - **2.2.5. Group**: A unique identifier for your project, typically the domain in reverse (e.g., `com.example`).
    - **2.2.6. Artifact**: The name of the project artifact, typically the application name (e.g., `demo`).
    - **2.2.7. Name**: Name of the application (this is also used in your `pom.xml` or `build.gradle` file).
    - **2.2.8. Description**: A brief description of your project.
    - **2.2.9. Package Name**: Default package name (you can leave it as the default or customize it).
    - **2.2.10. Packaging**: Choose either **Jar** or **War** (most projects use **Jar**).
    - **2.2.11. Java Version**: Choose the appropriate Java version (e.g., **Java 11** or **Java 17**).
3. Select the necessary **dependencies** from the available list.
4. Click **Generate** to download the generated zip file.
5. Extract the zip file and import it into your IDE.

---

#### **2.3. Spring Initializr Options**

#### **2.3.1. Project Metadata**

The following fields define the basic setup for your Spring Boot project:

- **2.3.1.1. Project**:
  - **Maven Project**: Uses Maven as the build tool.
  - **Gradle Project**: Uses Gradle as the build tool.
  
- **2.3.1.2. Language**:
  - **Java**: The most commonly used language with Spring Boot.
  - **Kotlin**: A modern, concise language that works well with Spring Boot, especially for new projects.
  - **Groovy**: Another language supported by Spring Boot, commonly used with Gradle.

- **2.3.1.3. Spring Boot Version**: The version of Spring Boot to use. It is always recommended to use the latest stable version unless you have a specific reason to use an older one.

- **2.3.1.4. Group**: The base package name for your application (e.g., `com.example`).
  
- **2.3.1.5. Artifact**: The name of the artifact being generated (e.g., `demo`).

- **2.3.1.6. Name**: The name of the project/application (e.g., `demo`).

- **2.3.1.7. Description**: A short description of your application.

- **2.3.1.8. Package Name**: This is the base package for your project.

- **2.3.1.9. Packaging**: The type of package to be created. You can choose between:
  - **Jar**: Typically used for Spring Boot applications.
  - **War**: Typically used for applications that need to be deployed to a web server (e.g., Tomcat).

- **2.3.1.10. Java Version**: Choose the appropriate version of Java that your project will use (e.g., **Java 8**, **Java 11**, **Java 17**).

---

#### **2.3.2. Dependencies**

Spring Initializr provides a wide range of dependencies to add to your project. Below are descriptions of some common dependencies you may choose:

#### **2.3.2.1. Spring Web**
- **Description**: This dependency is used for building web applications and RESTful web services. It includes Spring MVC and embedded servers such as Tomcat, Jetty, or Undertow. You’ll typically include this in applications that need web support (e.g., a REST API, a server-side web app, etc.).

#### **2.3.2.2. Spring Data JPA**
- **Description**: This dependency provides support for integrating with relational databases using Java Persistence API (JPA). It simplifies database operations and makes it easier to interact with relational databases using repository patterns. Typically used in applications where you need to perform CRUD operations on relational databases.

#### **2.3.2.3. MySQL Driver**
- **Description**: The MySQL Driver dependency provides the necessary drivers to connect your Spring Boot application to a MySQL database. If you're using MySQL for your application's data storage, you'll need this driver to facilitate database communication.

#### **2.3.2.4. Spring Boot DevTools**
- **Description**: Spring Boot DevTools enhances the development experience by providing additional features like automatic restarts, live reload, and debugging tools. It is specifically useful during the development phase as it speeds up the testing and debugging cycle by reloading your application upon changes.

#### **2.3.2.5. Lombok**
- **Description**: Lombok is a library that automatically generates commonly used code, such as getters, setters, `toString()`, `equals()`, and `hashCode()` methods, constructors, etc., by annotating your classes with special annotations. This helps reduce boilerplate code and improves the readability of your application, especially when working with POJOs (Plain Old Java Objects).

#### **2.3.2.6. Spring Boot**
- **Description**: This is the core dependency for Spring Boot applications. It includes essential features such as auto-configuration, embedded servers (like Tomcat, Jetty), and starters (pre-configured, ready-to-use components) that make it easier to set up and run Spring applications with minimal configuration. It is the foundation of your Spring Boot project.

---

#### **2.4. Packaging**

When generating a Spring Boot project, you can choose between two types of packaging:

- **2.4.1. Jar**:
  - JAR (Java Archive) is the most common packaging format for Spring Boot applications. It can be run on any platform with the appropriate JVM. It contains the compiled classes, libraries, resources, and metadata required to run the application.

- **2.4.2. War**:
  - WAR (Web Archive) packaging is used when you want to deploy your application to a servlet container (e.g., Tomcat). You may use WAR packaging when your application is designed to be deployed on traditional web servers.

---

#### **2.5. Java Version**

  - **2.5.1. Java 17** (LTS)

---

#### **2.6. Spring Initializr in IDEs**

Most popular IDEs support **Spring Initializr** for creating Spring Boot projects directly from the IDE. Here’s how you can use it in the most popular IDEs:

#### **2.6.1. IntelliJ IDEA:**
1. Open IntelliJ IDEA.
2. Click on **Create New Project**.
3. Choose **Spring Initializr** from the left sidebar.
4. Configure the project metadata and dependencies as described above.
5. Click **Next** and finish the setup.
6. IntelliJ IDEA will generate the project and import it into your workspace.

#### **2.6.2. Eclipse:**
1. Open Eclipse IDE.
2. Go to **File > New > Project**.
3. Select **Spring Starter Project** under the Spring category.
4. Fill in the project metadata and choose dependencies.
5. Click **Finish** to generate the project.

#### **2.6.3. Visual Studio Code:**
1. Install the **Spring Initializr** extension from the marketplace.
2. Open the Command Palette (Ctrl+Shift+P) and search for **Spring Initializr: Generate a Maven Project**.
3. Follow the prompts to select project metadata and dependencies.
4. The project will be generated and opened in VS Code.

---

#### **2.7. How Spring Initializr Works**

When you configure your project and click **Generate**, Spring Initializr:

1. Collects the metadata and dependencies you selected.
2. Generates the necessary project structure, including:
   - **`pom.xml`** or **`build.gradle`** (depending on the selected build tool).
   - **`application.properties`** or **`application.yml`** for application configuration.
   - The **main class** (e.g., `DemoApplication.java`) containing the `main()` method to run the Spring Boot application.
3. Zips the project into a downloadable archive.
4. You can extract the archive and open the project in your IDE.

Spring Initializr also supports generating projects with specific versions of Spring Boot, making it compatible with various Spring Boot versions.

---

#### **2.8. References**

- [Spring Initializr Documentation](https://docs.spring.io/initializr/docs/current/reference/html/)
- [Spring Boot Documentation](https://docs.spring.io/spring-boot/docs/current/reference/html/)
- [Spring Initializr GitHub Repository](https://github.com/spring-io/initializr)

---

### 3. SocketIO

#### 3.1. What is Socket.IO?

**Socket.IO** is a JavaScript library that enables real-time, bi-directional communication between web clients (such as browsers) and servers over **WebSockets** or other protocols. It's often used in applications that require real-time updates, such as messaging apps, live notifications, and multiplayer games.

Socket.IO is built on top of **WebSockets**, but it offers additional features like automatic reconnection, fallback mechanisms (e.g., using long polling when WebSockets are unavailable), and broadcasting, which makes it more reliable and easier to work with compared to raw WebSocket connections.

#### 3.1.1. Key Features of Socket.IO:

3.1.1.1. **Real-time Communication**: Allows real-time, low-latency communication between the server and the client. For example, a message can be sent from the server to the client and vice versa in real-time.
3.1.1.2. **Bi-directional Communication**: Both the client and server can send messages to each other, making it ideal for interactive applications like chat apps or live collaboration tools.
3.1.1.3. **Automatic Reconnection**: Socket.IO automatically tries to reconnect when the connection is lost, ensuring reliability.
3.1.1.4. **Fallbacks**: If WebSockets are not supported, Socket.IO can automatically fall back to other communication protocols, such as long polling.
3.1.1.5. **Namespaces**: Allows you to divide your application into different channels (called namespaces), enabling message isolation between them.
3.1.1.6. **Rooms**: A way of grouping clients together, which makes it easier to broadcast messages to certain groups of users.
3.1.1.7. **Event-based Communication**: Uses a simple event-driven architecture. Clients and servers emit and listen to events, making the interaction very intuitive.

---

#### 3.2. Which version have we used in the application?

#### **Socket.IO Version 2.0.12 Overview**

Socket.IO **version 2.0.12** is a **patch version** of **Socket.IO 2.x**, released after version 2.0, which brought significant changes to Socket.IO’s core architecture, including improved performance, support for newer browser versions, and API changes.

#### 3.2.1 **Key Features and Updates in Socket.IO 2.0.12**

While Socket.IO 2.x includes several important changes, version **2.0.12** (released in 2019) focused mainly on **bug fixes**, minor improvements, and ensuring compatibility with the latest platforms and environments.

---

#### Socket.IO Configuration in the Application

```java
import com.corundumstudio.socketio.Configuration;
import com.corundumstudio.socketio.SocketIOServer;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class SocketIOConfig {

    @Bean
    public SocketIOServer socketIOServer() {
        Configuration config = new Configuration();
        config.setHostname("localhost");
        config.setPort(8080);
        config.setOrigin("*");

        return new SocketIOServer(config);
    }
}
```

#### 3.2.2. Explanation of Configuration Code in Detail

#### 3.2.2.1. **Package Imports** 
```java

import com.corundumstudio.socketio.Configuration; 

import com.corundumstudio.socketio.SocketIOServer; 

import org.springframework.context.annotation.Bean;
``` 

- **com.corundumstudio.socketio.Configuration**: This class is used to configure various settings for the **Socket.IO server** (such as the hostname, port, and other parameters). 
- **com.corundumstudio.socketio.SocketIOServer**: This is the main class that represents the **Socket.IO server**. It is responsible for starting the server, managing connections, and handling events. 
- **org.springframework.context.annotation.Bean**: The @Bean annotation from Spring is used to indicate that the method that follows should be treated as a **bean definition**. This allows Spring to manage the lifecycle of the SocketIOServer object and inject it into other parts of the application.

#### 3.2.2.2. **@Configuration Annotation** 
```java
@org.springframework.context.annotation.Configuration 

public class SocketIOConfig { 
```
- **@Configuration**: This annotation is used to define a **Spring configuration class**, which contains bean definitions for the Spring IoC (Inversion of Control) container. By marking the class with @Configuration, we tell Spring to treat it as a source of bean definitions, which are later injected where needed. 
- **public class SocketIOConfig**: This is the class where we configure the Socket.IO server. The class is named `SocketIOConfig` to reflect that it holds the configuration for Socket.IO.

#### 3.2.2.3. **@Bean Method for Socket.IO Server** 
```java
@Bean 

public SocketIOServer socketIOServer() { 

`    `Configuration config = new Configuration(); 

`    `config.setHostname("localhost"); 

`    `config.setPort(8080); 

`    `config.setOrigin("\*"); 

`    `return new SocketIOServer(config); 

} 
```
- **@Bean**: The @Bean annotation is used to declare a method as a **Spring Bean**. When Spring sees this annotation, it will call this method, create an object (in this case, a `SocketIOServer`), and manage it as a Spring-managed bean. This makes it possible to inject `SocketIOServer` into other components of the Spring application, enabling real-time communication features. 

- **public SocketIOServer socketIOServer()**: This is the method definition that returns a `SocketIOServer` bean. This method creates and configures a `SocketIOServer` instance, which is the core of your Socket.IO server.

 

#### 3.3. **Creating and Configuring the Socket.IO Server:** 

3.3.1. - **Configuration config = new Configuration();**: 
  - The `Configuration` class is used to hold the various configuration parameters for the Socket.IO server (such as hostname, port, and origins).
  
3.3.2. - **config.setHostname("localhost");**: 
  - This sets the **hostname** to "localhost". This means the server will only be accessible on the local machine (localhost). If you wanted the server to be accessible externally, you would need to set this to your machine's IP address or a domain name (like "example.com").
  
3.3.3. - **config.setPort(8080);**: 
  - This sets the **port** number for the Socket.IO server to listen on. In this case, the server will listen on port 8080. This is the same port number often used by web servers for development, so it will be accessible at [http://localhost:8080](http://localhost:8080) in a browser (or through WebSocket connections).

3.3.4. - **config.setOrigin("\*");**: 
  - This sets the **CORS (Cross-Origin Resource Sharing)** settings for the server. `setOrigin("*")` allows connections from any origin. This is useful in development environments or when your server needs to accept requests from multiple domains. In a production environment, you may want to restrict the allowed origins for security purposes (e.g., `config.setOrigin("https://example.com");`).

3.3.4. - **return new SocketIOServer(config);**: 
  - Finally, a **new SocketIOServer** instance is created with the configured `Configuration` object and returned from the method. This instance is now managed by the Spring context as a bean and can be used to listen for connections, emit events, and broadcast messages.

---

#### 3.4. **Why is This Code Used?**

This configuration is used to **initialize a Socket.IO server** within a Spring Boot application. The server is then capable of handling **real-time communication** with clients (e.g., web browsers, mobile apps). Socket.IO is used for applications that need low-latency, bidirectional communication, such as:

- **Chat applications** 
- **Real-time notifications** 
- **Collaborative tools**
- **Live updates** (sports scores, stock prices, etc.)
- **Multiplayer games** 

The `SocketIOServer` will listen for connections on the specified port (8080), handle events like user connections and disconnections, and can send/receive messages in real time.

---

#### 3.5 **How This Fits into the Spring Boot Application:** 

3.5.1. **Spring Boot Integration:**
   - Spring Boot applications typically use `@Configuration` classes to define and configure beans. In this case, we define a `SocketIOServer` bean, which is then available for injection into other components of the application.

3.5.2. **Real-Time Communication:**
   - With this configuration, the Socket.IO server is set up to handle real-time communication for clients that connect to the Spring Boot backend. The clients could be web clients (using **JavaScript Socket.IO client**), mobile apps, or even desktop applications.

3.5.3. **Dependency Injection:**
   - Spring will manage the lifecycle of the `SocketIOServer` bean. This means you can inject this `SocketIOServer` into other Spring beans to interact with the Socket.IO server and manage connections.

---

#### 3.6 **Potential Use Case**

In a typical scenario, after configuring the `SocketIOServer`:

- You might define a **Socket.IO event listener** that listens for custom events (e.g., messages, user actions).
- You could use **broadcasting** to send real-time updates to multiple connected clients.
- The **Socket.IO server** could emit events back to the client or listen for client messages and trigger actions on the backend.

For example, you might have a **message event** where a client sends a message to the server, and the server broadcasts it to all other connected clients. 

java 

Copy: 
```java
socketIOServer.addEventListener("message", String.class, (client, data, ackSender) -> { 

socketIOServer.getBroadcastOperations().sendEvent("newMessage", data); 

}); 
```
3.6.1. **Key Concepts:** 

- **Spring Boot Configuration**: Using `@Configuration` and `@Bean` to configure and manage `SocketIOServer` as a Spring bean.
- **Socket.IO Server**: A server that manages real-time communication using WebSockets or other protocols and is integrated into a Spring Boot application.
- **Event-driven Architecture**: Using Socket.IO to send and receive events, enabling real-time bidirectional communication between server and client.

#### 3.7 **Conclusion**:

This configuration class sets up a **Socket.IO server** that listens for WebSocket connections on a Spring Boot backend. By doing so, it enables your application to support **real-time communication** with clients. Using **Spring's dependency injection** and **Socket.IO's real-time capabilities**, your app can handle events, broadcast updates, and communicate with clients instantly.

#### 3.8 **Set up of Socket.IO using ReactJS (with Vite) on the Front End and Spring Boot on the Back End for Real-Time Communication**

#### **Overview**

- **Backend**: We'll use **Spring Boot** with **Socket.IO** for handling real-time connections.
- **Frontend**: We'll use **ReactJS** (created using **Vite**) and the **Socket.IO client** to connect to the Spring Boot server for real-time communication.

#### 3.8.1 **Backend: Spring Boot + Socket.IO**

#### 3.8.1.1 **Step 1: Set up Spring Boot with Socket.IO** 

1. **Create a Spring Boot project** using Spring Initializr or your preferred IDE. 
   - Dependencies: 
     - **Spring Web** (for basic REST APIs)
     - **Socket.IO** (via the `netty-socketio` library)

2. **Add dependencies to `pom.xml`:** 

```xml
<dependencies>
    <!-- Spring Boot Starter Web -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>

    <!-- Socket.IO (Netty version) -->
    <dependency>
        <groupId>com.corundumstudio.socketio</groupId>
        <artifactId>netty-socketio</artifactId>
        <version>2.0.0</version> <!-- Make sure to use the correct version -->
    </dependency>

    <!-- Spring Boot Starter for JPA (Optional, if using databases) -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-jpa</artifactId>
    </dependency>
</dependencies>
```
#### **Step 3: Create `SocketIOConfig.java` to Configure the Socket.IO Server**

#### `SocketIOConfig.java`

```java
import com.corundumstudio.socketio.Configuration;
import com.corundumstudio.socketio.SocketIOServer;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class SocketIOConfig {

    @Bean
    public SocketIOServer socketIOServer() {
        // Create the configuration object for Socket.IO server
        Configuration config = new Configuration();

        // Set the hostname to localhost and port to 8080
        config.setHostname("localhost");
        config.setPort(8080); // Socket.IO server listens on port 8080

        // Set origin to '*' to allow all origins (adjust for production)
        config.setOrigin("*");

        // Initialize the Socket.IO server with the configuration
        SocketIOServer server = new SocketIOServer(config);

        // Listen to 'chat' events from the client
        server.addEventListener("chat", String.class, (client, data, ackSender) -> {
            System.out.println("Message received from client: " + data);

            // Broadcast the message to all connected clients
            server.getBroadcastOperations().sendEvent("chat", data);
        });

        // Start the Socket.IO server
        server.start();

        // Return the SocketIOServer bean to be managed by Spring
        return server;
    }
}
```
- In this configuration, we are setting up a **Socket.IO server** that listens for **"chat"** events and sends the received data to all connected clients (broadcasting).

---

#### **Step 4: Create `SocketController.java` (Optional)** to Expose an HTTP Endpoint

If you need to expose additional HTTP endpoints along with the Socket.IO server, you can create a simple controller. Below is an optional example of a Spring Boot controller.

#### `SocketController.java`

```java
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class SocketController {

    @GetMapping("/hello")
    public String hello() {
        return "Hello from Spring Boot!";
    }
}
```
#### **Step 5: Run the Spring Boot Application** This starts a **Socket.IO server** on localhost:8080. 

#### 3.8.2 **Frontend: ReactJS + Vite + Socket.IO Client**

#### 3.8.2.1 **Step 2: Set up React with Vite and Socket.IO Client**

1. **Create a new React app** using **Vite**:

   Run the following command to create a new React app with the Vite template:

   ```bash
   npm create vite@latest my-app --template react
   cd my-app
   ```

---

#### **Step 2: Install the required dependencies**

To enable real-time communication between the React frontend and the Socket.IO server, you need to install the **Socket.IO client**.

Run the following command to install it:

```bash
npm install socket.io-client
```

---

#### **Step 3: Create the ChatApp.js Component**

In this step, you will create a **ChatApp.js** component that allows the user to send and receive messages using **Socket.IO**.

```jsx
import { useState, useEffect } from "react";
import { io } from "socket.io-client";

// Connect to the Spring Boot Socket.IO server
const socket = io("http://localhost:8080");

function ChatApp() {
  const [message, setMessage] = useState("");
  const [messages, setMessages] = useState([]);

  // Listen for incoming messages from the server
  useEffect(() => {
    socket.on("chat", (data) => {
      setMessages((prevMessages) => [...prevMessages, data]);
    });

    // Clean up the socket connection when the component is unmounted
    return () => {
      socket.off("chat");
    };
  }, []);

  // Handle sending messages to the server
  const sendMessage = () => {
    if (message.trim() !== "") {
      socket.emit("chat", message); // Emit "chat" event to the server
      setMessage(""); // Clear the input field
    }
  };

  return (
    <div>
      <h2>Socket.IO Chat</h2>
      <div>
        <div style={{ marginBottom: "20px" }}>
          {messages.map((msg, index) => (
            <div key={index}>{msg}</div>
          ))}
        </div>
        <input
          type="text"
          value={message}
          onChange={(e) => setMessage(e.target.value)}
          placeholder="Type a message"
        />
        <button onClick={sendMessage}>Send</button>
      </div>
    </div>
  );
}

export default ChatApp;
```

---

#### **Understanding Key Parts of the Code:**

1. **Connecting to the Socket.IO Server**:
   - `socket = io("http://localhost:8080")`: 
     - This establishes a WebSocket connection to the **Socket.IO server** running on `localhost:8080`, which is handled by the Spring Boot backend. 
     - The `io()` function from the `socket.io-client` library is used to initiate this connection.

2. **Handling Incoming Messages**:
   - `socket.on("chat", (data) => {...})`: 
     - Listens for the `"chat"` event emitted by the server.
     - When a message is received, it adds the message to the `messages` state array, which updates the UI to display the new message.

3. **Sending Messages**:
   - `socket.emit("chat", message)`:
     - This sends the `"chat"` event to the Socket.IO server along with the message content (`message`).
     - The server receives the event and can broadcast it to all connected clients, enabling real-time communication between them.

---

#### **Summary:**

- The **Socket.IO client** in the React app connects to the backend, listens for incoming messages, and sends messages to the server using the `emit` and `on` methods.
- This allows for **bidirectional, real-time communication** between the frontend (ReactJS) and the backend (Spring Boot with Socket.IO).

---

---

#### 3.8.3 **Step 3: Update `App.js` to Use `ChatApp` Component**

In this step, you'll import the `ChatApp` component into the `App.js` file and render it inside the main application.

#### **Code:**
```jsx
import React from "react"; 
import ChatApp from "./ChatApp"; // Import the ChatApp component

function App() { 
  return ( 
    <div className="App">
      <ChatApp />  {/* Render the ChatApp component */}
    </div> 
  ); 
}

export default App;
```

---

#### 3.8.4 **Step 4: Run the React + Vite Application**

#### **1. Start the React Development Server**:

To run the React application, execute the following command:

```bash
npm run dev
```

---

#### 3.9 **How Socket.IO Works Here:**

#### 3.9.1. Backend (Spring Boot):**
1. When a client sends a chat event (through `socket.emit("chat", message)`), the Spring Boot backend receives it via `server.addEventListener("chat", ...)`.
2. The backend then broadcasts the message to all connected clients using `server.getBroadcastOperations().sendEvent("chat", data)`.

#### 3.9.2. Frontend (React + Vite):**
1. The React app listens for the `chat` event through `socket.on("chat", ...)`, and when the event is received, it updates the UI with the new message.
2. When a user sends a message, the React app emits a `chat` event to the Spring Boot server, which broadcasts it back to all connected clients.

---

#### 3.10 **Summary of Communication Flow:**

3.10.1. **User Interaction**: 
   - The user types a message in the React app and clicks the "Send" button.
   
3.10.2. **Frontend**: 
   - The React app emits a `chat` event to the Spring Boot backend.
   
3.10.3. **Backend**: 
   - The Spring Boot server receives the `chat` event, processes it, and broadcasts it to all connected clients.
   
3.10.4. **Frontend**: 
   - All connected React clients receive the `chat` event and update their UI with the new message.

---

#### 3.11 **Testing It:**

3.11.1. Open **two browser windows** at [http://localhost:3000](http://localhost:3000).
3.11.2. Send a message in one window, and you should see the message appear in real-time in the other window.
3.11.3. The message is sent from the client to the server, and the server broadcasts it to all connected clients.

---

#### **Conclusion**

This setup demonstrates how to use **Socket.IO** for real-time communication between a **React frontend** and a **Spring Boot backend**. By combining the power of **Socket.IO** for event-driven, bi-directional communication with **Spring Boot** and **ReactJS**, you can easily build interactive real-time web applications.

---
### 4. Configuration of application.properties

#### 3.1. what is application.properties?
In Spring Boot, `application.properties` is a configuration file that allows you to set various properties to customize the behavior of the application. It's the default file used to store configuration settings for different components of a Spring Boot application, such as the server, database, logging, security, and more.

It can be used to configure properties related to:

- **Database connections**
- **Server settings** (e.g., port number, context path)
- **Logging configuration**
- **JPA** (Java Persistence API) settings
- **Security properties**
- **File upload limits**
- **Spring-specific configuration properties** (such as cache, session management, etc.)

You can use `application.properties` to configure your Spring Boot application in a **centralized** and **externalized** way, so the application can be easily customized without having to modify the source code.

##How has the application.properties file been configured in the application?
```java
spring.application.name=157-project1
server.port=3000
spring.datasource.url=jdbc:MySql://localhost:3306/157task
spring.datasource.username=root
spring.datasource.password=8446394639
#spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver

spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL8Dialect
spring.servlet.multipart.enabled=true
spring.servlet.multipart.max-file-size=10MB
spring.servlet.multipart.max-request-size=10MB
```

#### Explanation of `application.properties` Configuration

This configuration file is typically found in the `application.properties` file in a Spring Boot project. It's used to configure various properties for the Spring Boot application, such as server settings, data source (database) configurations, and file upload settings. Let's go through each line of this file to explain its significance.

#### 1. `spring.application.name=157-project1`
- **Purpose**: This sets the name of the Spring Boot application. It's useful for identifying the application, especially when using tools like Spring Boot Admin or logging.
- **Why it's necessary**: It helps give a human-readable name to the application, which is particularly useful when you have multiple services running.

#### 2. `server.port=3000`
- **Purpose**: This sets the port on which the embedded web server (e.g., Tomcat) will run. By default, Spring Boot runs on port 8080, but in this case, it's explicitly set to run on port 3000.
- **Why it's necessary**: This is needed if you want to change the default port Spring Boot uses to a custom port (in this case, port 3000). You might need to change it to avoid port conflicts or for specific requirements in your environment.

#### 3. `spring.datasource.url=jdbc:MySql://localhost:3306/157task`
- **Purpose**: This property configures the URL of the database Spring Boot will connect to. The `jdbc:mysql://localhost:3306/157task` URL specifies that the application should use MySQL as the database and connect to it via localhost (the local machine) on port 3306 (default MySQL port). The database name is `157task`.
- **Why it's necessary**: This is needed to tell Spring Boot which database to connect to. Without this, the application won’t know where to find the database, and database operations would fail.

#### 4. `spring.datasource.username=root`
- **Purpose**: This specifies the username that Spring Boot will use to authenticate to the database. In this case, it is set to `root`, which is a default MySQL user.
- **Why it's necessary**: The username is required to connect to the database. It tells the application what credentials to use for accessing the database.

#### 5. `spring.datasource.password=8446394639`
- **Purpose**: This specifies the password corresponding to the username (`root` in this case). It's used for authenticating the connection to the MySQL database.
- **Why it's necessary**: The password is essential for authenticating the user and establishing a secure connection to the database.

#### 6. `#spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver`
- **Purpose**: This is a commented-out line (due to the `#` symbol) that typically specifies the driver class for the MySQL database. The driver class is necessary for connecting Java to MySQL. However, Spring Boot automatically detects the correct driver when using the `spring-boot-starter-data-jpa` dependency, so you generally don’t need to specify this unless there are specific issues.
- **Why it's necessary**: If you're using a database like MySQL, you would normally specify the driver class (`com.mysql.cj.jdbc.Driver`), but in most cases, Spring Boot can automatically detect it when the appropriate dependency (`spring-boot-starter-data-jpa`) is added. The commented-out line is simply a fallback or an optional setting.

#### 7. `spring.jpa.hibernate.ddl-auto=update`
- **Purpose**: This property tells Hibernate (the JPA implementation) how to handle database schema generation. The value `update` means that Hibernate will automatically update the database schema to match the entity classes each time the application is run.
    - Possible values:
        - `none`: No schema generation is performed.
        - `update`: Updates the schema by adding new tables/columns or modifying existing ones, but doesn't delete any data.
        - `create`: Drops and recreates the schema on each startup.
        - `create-drop`: Same as `create`, but it also drops the schema when the session factory is closed (useful for testing).
- **Why it's necessary**: This is important for automatic schema management. Setting it to `update` ensures that if your entity classes change, the database schema will automatically adjust accordingly.

#### 8. `spring.jpa.show-sql=true`
- **Purpose**: This property enables SQL logging. When set to `true`, it will log the SQL statements executed by Hibernate (or any JPA provider).
- **Why it's necessary**: It’s useful for debugging, as you can see the exact SQL queries that Hibernate is executing on the database. This helps when you want to verify the SQL that your entities are producing, especially during development.

#### 9. `spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL8Dialect`
- **Purpose**: This property defines the Hibernate dialect to use. The dialect is a Hibernate configuration setting that ensures the correct SQL is generated for the underlying database. In this case, `MySQL8Dialect` tells Hibernate to generate SQL optimized for MySQL 8.
- **Why it's necessary**: It's crucial to set the correct dialect so that Hibernate generates the right SQL syntax for your MySQL database. Without the proper dialect, Hibernate may produce SQL that’s not compatible with your database, leading to errors.

#### 10. `spring.servlet.multipart.enabled=true`
- **Purpose**: This property enables support for multipart file uploads in the application.
- **Why it's necessary**: It’s needed if your application will handle file uploads. For example, if you have a feature that allows users to upload images or documents, this property enables Spring Boot to handle those files.

#### 11. `spring.servlet.multipart.max-file-size=10MB`
- **Purpose**: This specifies the maximum allowed file size for uploads. In this case, it’s set to `10MB`.
- **Why it's necessary**: It defines a file size limit for uploads. This is useful to prevent users from uploading excessively large files that could impact server performance or stability. Without this, there would be no limit on the file sizes, which could be problematic.

#### 12. `spring.servlet.multipart.max-request-size=10MB`
- **Purpose**: This property sets the maximum size for an entire HTTP request, including the uploaded file(s). It’s also set to `10MB` in this case.
- **Why it's necessary**: It’s essential to have a limit on the total size of the request to avoid issues when dealing with multiple or very large files. Without this, users could upload very large files, potentially affecting the server’s memory and performance.

---

### 5. Back-End Code flow

#### 3.1. Add Employee

#### **Main class code:
```java
package _7.project1;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class Application {

	public static void main(String[] args) {
		SpringApplication.run(Application.class, args);
	}

}
```
#### **Explantion of code:
#### Spring Boot Application: `Application.java`

This is the main entry point of a Spring Boot application. Let's break it down:

#### 1. **`@SpringBootApplication` Annotation:**
   - **`@SpringBootApplication`** is a convenience annotation that combines the following:
     - **`@EnableAutoConfiguration`**: Tells Spring Boot to automatically configure your application based on the dependencies in the classpath.
     - **`@ComponentScan`**: Enables component scanning, so Spring can detect and register your beans (such as controllers, services, repositories, etc.) in the application context.
     - **`@Configuration`**: Indicates that this class contains Spring configuration (i.e., bean definitions).
   
   This annotation is typically placed on the main class of a Spring Boot application, as it kick-starts the auto-configuration and sets up the application context.

#### 2. **`public class Application`:**
   - This is the main class of the application. It's typically named `Application` or something similar, and it serves as the entry point for running the Spring Boot application.

#### 3. **`public static void main(String[] args)`:**
   - This is the main method that runs when the application starts.
   - **`String[] args`** allows command-line arguments to be passed when starting the application. These arguments are passed to `SpringApplication.run(...)`.
   
#### 4. **`SpringApplication.run(Application.class, args)`:**
   - **`SpringApplication.run(Application.class, args)`** is a method that launches the Spring Boot application.
     - **`Application.class`**: Refers to the class that contains the `@SpringBootApplication` annotation. It's the starting point of the Spring context.
     - **`args`**: These are the command-line arguments passed to the application.

   This method will initialize the Spring context and all the beans defined in the application, start the embedded web server (like Tomcat, Jetty, etc.), and handle HTTP requests (if your application is a web application). After calling this, the application starts running.

#### In Summary:
- **`@SpringBootApplication`** configures the Spring Boot application.
- **`main()` method** is the entry point for the Java application.
- **`SpringApplication.run()`** starts the Spring Boot application and the embedded web server.

This structure is standard for a Spring Boot application, and it's often referred to as the **"Spring Boot Bootstrap"** because it initializes the Spring context and enables all auto-configured components.

---


#### **Entity Code
```java
package _7.project1.Entity;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.NoArgsConstructor;

@Entity
@NoArgsConstructor
@AllArgsConstructor
@Table(name = "employee", uniqueConstraints = {@UniqueConstraint(columnNames = "user_name")})
public class Employee {

    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "employee_seq_generator")
    @SequenceGenerator(name = "employee_seq_generator", sequenceName = "employee_seq",
                 allocationSize = 1)
    @Column(name = "emp_id")
    private Long employee_Id;

    @Column(name = "employee_name")
    private String employeeName;

    @Column(name = "user_name", unique = true, nullable = false)
    private String userName;

    @Column(name = "date_of_joining")
    private String dateOfJoining;

    @Column(name = "designation")
    private String designation;

    @Column(name = "department")
    private String department;

    @Column(name = "official_mail")
    private String officialMail;

    @Column(name = "employee_email")
    private String employeeEmail;

    @Column(name = "official_contact_no")
    private long officialContactNumber;

    @Column(name = "alternate_contact_no")
    private long alternateContactNo;

    @Column(name = "date_of_birth")
    private String dateOfBirth;

    @Column(name = "gender")
    private String gender;

    @Column(name = "company_mobile_number")
    private long companyMobileNumber;

    @Column(name = "whats_App_number")
    private long whatsAppNumber;

    @Column(name = "emergency_contact_number")
    private String emergencyContactNumber;

    @Column(name = "emergency_person_relation")
    private String emergencyPersonRelation;

    @Column(name = "employee_present_address")
    private String employeePresentAddress;

    @Column(name = "employee_experience")
    private String employeeExperience;

    @Column(name = "perks")
    private String perks;

    @Column(name = "marital_status")
    private String maritalStatus;

    @Column(name = "anniversary_date")
    private String anniversaryDate;

    @Column(name = "t_shirt_size")
    private String tshirtSize;

    @Column(name = "last_company")
    private String lastCompany;

    @Column(name = "work_location")
    private String workLocation;

    @Column(name = "entry_source")
    private String entrySource;

    @Column(name = "employee_status")
    private String employeeStatus;

    @Column(name = "last_working_date")
    private String lastWorkingDate;

    @Column(name = "reason_for_leaving")
    private String reasonForLeaving;

    @Column(name = "induction_yes_or_no")
    private String inductionYesOrNo;

    @Column(name = "induction_comment")
    private String inductionComment;

    @Column(name = "training_source")
    private String trainingSource;

    @Column(name = "training_completed_yes_or_no")
    private String trainingCompletedYesOrNo;

    @Column(name = "training_taken_count")
    private int trainingTakenCount;

    @Column(name = "rounds_of_interview")
    private String roundsOfInterview;

    @Column(name = "interview_taken_person")
    private String interviewTakenPerson;

    @Column(name = "warning_comments")
    private String warningComments;

    @Column(name = "performance_indicator")
    private String performanceIndicator;

    @Column(name = "team_leader_msg")
    private String teamLeaderMsg;

    @Column(name = "edit_delete_authority")
    private String editDeleteAuthority;

    @Column(name = "linked_inurl")
    private String linkedInURl;

    @Column(name = "face_bookurl")
    private String faceBookURL;

    @Column(name = "twitterurl")
    private String twitterURl;

    @Column(name = "employee_address")
    private String employeeAddress;

    @Column(name = "blood_group")
    private String bloodGroup;

    @Column(name = "aadhaar_no")
    private long aadhaarNo;

    @Column(name = "pan_no")
    private String panNo;

    @Column(name = "educational_qualification")
    private String educationalQualification;

    @Column(name = "offered_salary")
    private double offeredSalary;

    @Column(name = "job_role")
    private String jobRole;

    @Column(name = "professional_pt_no")
    private long professionalPtNo;

    @Column(name = "es_ic_no")
    private long esIcNo;

    @Column(name = "pf_no")
    private long pfNo;

    private long insuranceNumber;
    private String reportingMangerName;
    private String reportingMangerDesignation;

    @Column(name = "employee_password")
    private String employeePassword;

    @Column(name = "confirm_password")
    private String confirmPassword;

    @Lob
    @Column(columnDefinition = "LONGBLOB", name = "profile_image")
    private byte[] profileImage;

    @Lob
    @Column(columnDefinition = "LONGBLOB", name = "document")
    private byte[] document;

    @Lob
    @Column(columnDefinition = "LONGBLOB", name = "resume_file")
    private byte[] resumeFile;

    private int oldTeamLeaderId;

    @Column(name = "login_status")
    private String loginStatus;

    public Long getEmployee_Id() {
        return employee_Id;
    }

    public void setEmployee_Id(Long employee_Id) {
        this.employee_Id = employee_Id;
    }

    public String getEmployeeName() {
        return employeeName;
    }

    public void setEmployeeName(String employeeName) {
        this.employeeName = employeeName;
    }

    public String getUserName() {
        return userName;
    }

    public void setUserName(String userName) {
        this.userName = userName;
    }

    public String getDateOfJoining() {
        return dateOfJoining;
    }

    public void setDateOfJoining(String dateOfJoining) {
        this.dateOfJoining = dateOfJoining;
    }

    public String getDesignation() {
        return designation;
    }

    public void setDesignation(String designation) {
        this.designation = designation;
    }

    public String getDepartment() {
        return department;
    }

    public void setDepartment(String department) {
        this.department = department;
    }

    public String getOfficialMail() {
        return officialMail;
    }

    public void setOfficialMail(String officialMail) {
        this.officialMail = officialMail;
    }

    public String getEmployeeEmail() {
        return employeeEmail;
    }

    public void setEmployeeEmail(String employeeEmail) {
        this.employeeEmail = employeeEmail;
    }

    public long getOfficialContactNumber() {
        return officialContactNumber;
    }

    public void setOfficialContactNumber(long officialContactNumber) {
        this.officialContactNumber = officialContactNumber;
    }

    public long getAlternateContactNo() {
        return alternateContactNo;
    }

    public void setAlternateContactNo(long alternateContactNo) {
        this.alternateContactNo = alternateContactNo;
    }

    public String getDateOfBirth() {
        return dateOfBirth;
    }

    public void setDateOfBirth(String dateOfBirth) {
        this.dateOfBirth = dateOfBirth;
    }

    public String getGender() {
        return gender;
    }

    public void setGender(String gender) {
        this.gender = gender;
    }

    public long getCompanyMobileNumber() {
        return companyMobileNumber;
    }

    public void setCompanyMobileNumber(long companyMobileNumber) {
        this.companyMobileNumber = companyMobileNumber;
    }

    public long getWhatsAppNumber() {
        return whatsAppNumber;
    }

    public void setWhatsAppNumber(long whatsAppNumber) {
        this.whatsAppNumber = whatsAppNumber;
    }

    public String getEmergencyContactNumber() {
        return emergencyContactNumber;
    }

    public void setEmergencyContactNumber(String emergencyContactNumber) {
        this.emergencyContactNumber = emergencyContactNumber;
    }

    public String getEmergencyPersonRelation() {
        return emergencyPersonRelation;
    }

    public void setEmergencyPersonRelation(String emergencyPersonRelation) {
        this.emergencyPersonRelation = emergencyPersonRelation;
    }

    public String getEmployeePresentAddress() {
        return employeePresentAddress;
    }

    public void setEmployeePresentAddress(String employeePresentAddress) {
        this.employeePresentAddress = employeePresentAddress;
    }

    public String getEmployeeExperience() {
        return employeeExperience;
    }

    public void setEmployeeExperience(String employeeExperience) {
        this.employeeExperience = employeeExperience;
    }

    public String getPerks() {
        return perks;
    }

    public void setPerks(String perks) {
        this.perks = perks;
    }

    public String getMaritalStatus() {
        return maritalStatus;
    }

    public void setMaritalStatus(String maritalStatus) {
        this.maritalStatus = maritalStatus;
    }

    public String getAnniversaryDate() {
        return anniversaryDate;
    }

    public void setAnniversaryDate(String anniversaryDate) {
        this.anniversaryDate = anniversaryDate;
    }

    public String getTshirtSize() {
        return tshirtSize;
    }

    public void setTshirtSize(String tshirtSize) {
        this.tshirtSize = tshirtSize;
    }

    public String getLastCompany() {
        return lastCompany;
    }

    public void setLastCompany(String lastCompany) {
        this.lastCompany = lastCompany;
    }

    public String getWorkLocation() {
        return workLocation;
    }

    public void setWorkLocation(String workLocation) {
        this.workLocation = workLocation;
    }

    public String getEntrySource() {
        return entrySource;
    }

    public void setEntrySource(String entrySource) {
        this.entrySource = entrySource;
    }

    public String getEmployeeStatus() {
        return employeeStatus;
    }

    public void setEmployeeStatus(String employeeStatus) {
        this.employeeStatus = employeeStatus;
    }

    public String getLastWorkingDate() {
        return lastWorkingDate;
    }

    public void setLastWorkingDate(String lastWorkingDate) {
        this.lastWorkingDate = lastWorkingDate;
    }

    public String getReasonForLeaving() {
        return reasonForLeaving;
    }

    public void setReasonForLeaving(String reasonForLeaving) {
        this.reasonForLeaving = reasonForLeaving;
    }

    public String getInductionYesOrNo() {
        return inductionYesOrNo;
    }

    public void setInductionYesOrNo(String inductionYesOrNo) {
        this.inductionYesOrNo = inductionYesOrNo;
    }

    public String getInductionComment() {
        return inductionComment;
    }

    public void setInductionComment(String inductionComment) {
        this.inductionComment = inductionComment;
    }

    public String getTrainingSource() {
        return trainingSource;
    }

    public void setTrainingSource(String trainingSource) {
        this.trainingSource = trainingSource;
    }

    public String getTrainingCompletedYesOrNo() {
        return trainingCompletedYesOrNo;
    }

    public void setTrainingCompletedYesOrNo(String trainingCompletedYesOrNo) {
        this.trainingCompletedYesOrNo = trainingCompletedYesOrNo;
    }

    public int getTrainingTakenCount() {
        return trainingTakenCount;
    }

    public void setTrainingTakenCount(int trainingTakenCount) {
        this.trainingTakenCount = trainingTakenCount;
    }

    public String getRoundsOfInterview() {
        return roundsOfInterview;
    }

    public void setRoundsOfInterview(String roundsOfInterview) {
        this.roundsOfInterview = roundsOfInterview;
    }

    public String getInterviewTakenPerson() {
        return interviewTakenPerson;
    }

    public void setInterviewTakenPerson(String interviewTakenPerson) {
        this.interviewTakenPerson = interviewTakenPerson;
    }

    public String getWarningComments() {
        return warningComments;
    }

    public void setWarningComments(String warningComments) {
        this.warningComments = warningComments;
    }

    public String getPerformanceIndicator() {
        return performanceIndicator;
    }

    public void setPerformanceIndicator(String performanceIndicator) {
        this.performanceIndicator = performanceIndicator;
    }

    public String getTeamLeaderMsg() {
        return teamLeaderMsg;
    }

    public void setTeamLeaderMsg(String teamLeaderMsg) {
        this.teamLeaderMsg = teamLeaderMsg;
    }

    public String getEditDeleteAuthority() {
        return editDeleteAuthority;
    }

    public void setEditDeleteAuthority(String editDeleteAuthority) {
        this.editDeleteAuthority = editDeleteAuthority;
    }

    public String getLinkedInURl() {
        return linkedInURl;
    }

    public void setLinkedInURl(String linkedInURl) {
        this.linkedInURl = linkedInURl;
    }

    public String getFaceBookURL() {
        return faceBookURL;
    }

    public void setFaceBookURL(String faceBookURL) {
        this.faceBookURL = faceBookURL;
    }

    public String getTwitterURl() {
        return twitterURl;
    }

    public void setTwitterURl(String twitterURl) {
        this.twitterURl = twitterURl;
    }

    public String getEmployeeAddress() {
        return employeeAddress;
    }

    public void setEmployeeAddress(String employeeAddress) {
        this.employeeAddress = employeeAddress;
    }

    public String getBloodGroup() {
        return bloodGroup;
    }

    public void setBloodGroup(String bloodGroup) {
        this.bloodGroup = bloodGroup;
    }

    public long getAadhaarNo() {
        return aadhaarNo;
    }

    public void setAadhaarNo(long aadhaarNo) {
        this.aadhaarNo = aadhaarNo;
    }

    public String getPanNo() {
        return panNo;
    }

    public void setPanNo(String panNo) {
        this.panNo = panNo;
    }

    public String getEducationalQualification() {
        return educationalQualification;
    }

    public void setEducationalQualification(String educationalQualification) {
        this.educationalQualification = educationalQualification;
    }

    public double getOfferedSalary() {
        return offeredSalary;
    }

    public void setOfferedSalary(double offeredSalary) {
        this.offeredSalary = offeredSalary;
    }

    public String getJobRole() {
        return jobRole;
    }

    public void setJobRole(String jobRole) {
        this.jobRole = jobRole;
    }

    public long getProfessionalPtNo() {
        return professionalPtNo;
    }

    public void setProfessionalPtNo(long professionalPtNo) {
        this.professionalPtNo = professionalPtNo;
    }

    public long getEsIcNo() {
        return esIcNo;
    }

    public void setEsIcNo(long esIcNo) {
        this.esIcNo = esIcNo;
    }

    public long getPfNo() {
        return pfNo;
    }

    public void setPfNo(long pfNo) {
        this.pfNo = pfNo;
    }

    public long getInsuranceNumber() {
        return insuranceNumber;
    }

    public void setInsuranceNumber(long insuranceNumber) {
        this.insuranceNumber = insuranceNumber;
    }

    public String getReportingMangerName() {
        return reportingMangerName;
    }

    public void setReportingMangerName(String reportingMangerName) {
        this.reportingMangerName = reportingMangerName;
    }

    public String getReportingMangerDesignation() {
        return reportingMangerDesignation;
    }

    public void setReportingMangerDesignation(String reportingMangerDesignation) {
        this.reportingMangerDesignation = reportingMangerDesignation;
    }

    public String getEmployeePassword() {
        return employeePassword;
    }

    public void setEmployeePassword(String employeePassword) {
        this.employeePassword = employeePassword;
    }

    public String getConfirmPassword() {
        return confirmPassword;
    }

    public void setConfirmPassword(String confirmPassword) {
        this.confirmPassword = confirmPassword;
    }

    public byte[] getProfileImage() {
        return profileImage;
    }

    public void setProfileImage(byte[] profileImage) {
        this.profileImage = profileImage;
    }

    public byte[] getDocument() {
        return document;
    }

    public void setDocument(byte[] document) {
        this.document = document;
    }

    public byte[] getResumeFile() {
        return resumeFile;
    }

    public void setResumeFile(byte[] resumeFile) {
        this.resumeFile = resumeFile;
    }

    public int getOldTeamLeaderId() {
        return oldTeamLeaderId;
    }

    public void setOldTeamLeaderId(int oldTeamLeaderId) {
        this.oldTeamLeaderId = oldTeamLeaderId;
    }

    public String getLoginStatus() {
        return loginStatus;
    }

    public void setLoginStatus(String loginStatus) {
        this.loginStatus = loginStatus;
    }
}

```
#### **Explanation of code:
### Employee Entity Class (JPA Model)

This Java class represents an **Employee** entity in a database using **JPA (Java Persistence API)**. It is annotated with **Jakarta Persistence** annotations and **Lombok** annotations to simplify the code.

### 1. Annotations:
- **`@Entity`**: Marks the class as a JPA entity, indicating that it will map to a table in the database.
- **`@Table(name = "employee", uniqueConstraints = {@UniqueConstraint(columnNames = "user_name")})`**: Specifies the name of the table (`employee`) and enforces a unique constraint on the `user_name` column.
- **`@Id`**: Denotes that the `employee_Id` field is the primary key of the entity.
- **`@GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "employee_seq_generator")`**: Specifies how the `employee_Id` value will be generated, using a sequence generator defined by `@SequenceGenerator`.
- **`@SequenceGenerator(name = "employee_seq_generator", sequenceName = "employee_seq", allocationSize = 1)`**: Defines the sequence generator used to generate primary key values.
- **`@Column`**: Maps the class fields to corresponding columns in the database table. It allows specifying additional constraints like `nullable`, `unique`, etc.
- **`@Lob`**: Indicates that the field should be stored as a large object (binary data like files or large text). This is used for `profile_image`, `document`, and `resume_file`.

#### 2. Fields (Attributes):
The class has numerous fields, each representing a piece of information about an employee. The fields have various data types like `String`, `long`, `double`, and `byte[]` (for storing large binary objects). Here’s an overview of what each field represents:

- **Basic Info**: `employee_Id`, `employeeName`, `userName`, `dateOfJoining`, `dateOfBirth`, `gender`, `maritalStatus`, etc.
- **Contact Info**: `officialMail`, `employeeEmail`, `officialContactNumber`, `companyMobileNumber`, `whatsAppNumber`, etc.
- **Job Details**: `designation`, `department`, `lastCompany`, `workLocation`, `jobRole`, `offeredSalary`, etc.
- **Personal Info**: `bloodGroup`, `aadhaarNo`, `panNo`, `employeeAddress`, etc.
- **Emergency Info**: `emergencyContactNumber`, `emergencyPersonRelation`, etc.
- **Miscellaneous**: `perks`, `employeeStatus`, `inductionYesOrNo`, `performanceIndicator`, etc.
- **Social Media/Links**: `linkedInURl`, `faceBookURL`, `twitterURl`.
- **Documents**: `profileImage`, `document`, `resumeFile` (stored as large binary objects using `@Lob`).

#### 3. Lombok Annotations:
- **`@NoArgsConstructor`**: Automatically generates a no-argument constructor for the class. This is required by JPA for creating instances.
- **`@AllArgsConstructor`**: Generates a constructor with parameters for all fields in the class. This allows creating objects with all properties at once.

#### 4. Other Attributes:
- **Profile Image/Document/Resume**: These are stored as binary data (`byte[]`), and **`@Lob`** is used to indicate that they are large objects (e.g., images, PDFs).
- **Login and Authority**: Fields like `loginStatus` and `editDeleteAuthority` control permissions and the user’s login status.
- **Miscellaneous Fields**: Fields like `inductionComment`, `performanceIndicator`, and `teamLeaderMsg` are likely used to store feedback or comments related to the employee’s performance or other work-related aspects.

#### 5. Methods:
The class includes **getters and setters** for all fields. These methods are generated manually, but **Lombok** annotations (`@NoArgsConstructor` and `@AllArgsConstructor`) help reduce boilerplate code for constructors.

#### Summary of What's Happening:
- The **Employee** class represents an entity in a relational database, capturing various details about an employee (personal, contact, job-related, etc.).
- **JPA annotations** are used to map the class to a table and define column mappings, constraints (like primary key generation and unique constraints).
- **Lombok annotations** reduce boilerplate code by automatically generating constructors.
- The class handles **binary data** (like profile images and documents) using `@Lob`, indicating these fields store large binary objects.
- The class facilitates interaction with a database by storing employee details, possibly using **EntityManager** or **JpaRepository** for persistence operations.


#### **Repository code:
```java
package _7.project1.Repository;

import _7.project1.Entity.Employee;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import java.util.Optional;

@Repository
public interface EmployeeRepository extends JpaRepository<Employee, Long> {
    Optional<Employee> findByUserName(String username);
    Optional<Employee> findById(Long id);
}
```
#### **Explanation of code:
#### Spring Boot Application: `Application.java`

This is the main entry point of a Spring Boot application. Let's break it down:

#### 1. **`@SpringBootApplication` Annotation:**
   - **`@SpringBootApplication`** is a convenience annotation that combines the following:
     - **`@EnableAutoConfiguration`**: Tells Spring Boot to automatically configure your application based on the dependencies in the classpath.
     - **`@ComponentScan`**: Enables component scanning, so Spring can detect and register your beans (such as controllers, services, repositories, etc.) in the application context.
     - **`@Configuration`**: Indicates that this class contains Spring configuration (i.e., bean definitions).
   
   This annotation is typically placed on the main class of a Spring Boot application, as it kick-starts the auto-configuration and sets up the application context.

#### 2. **`public class Application`:**
   - This is the main class of the application. It's typically named `Application` or something similar, and it serves as the entry point for running the Spring Boot application.

#### 3. **`public static void main(String[] args)`:**
   - This is the main method that runs when the application starts.
   - **`String[] args`** allows command-line arguments to be passed when starting the application. These arguments are passed to `SpringApplication.run(...)`.
   
#### 4. **`SpringApplication.run(Application.class, args)`:**
   - **`SpringApplication.run(Application.class, args)`** is a method that launches the Spring Boot application.
     - **`Application.class`**: Refers to the class that contains the `@SpringBootApplication` annotation. It's the starting point of the Spring context.
     - **`args`**: These are the command-line arguments passed to the application.

   This method will initialize the Spring context and all the beans defined in the application, start the embedded web server (like Tomcat, Jetty, etc.), and handle HTTP requests (if your application is a web application). After calling this, the application starts running.

#### In Summary:
- **`@SpringBootApplication`** configures the Spring Boot application.
- **`main()` method** is the entry point for the Java application.
- **`SpringApplication.run()`** starts the Spring Boot application and the embedded web server.

This structure is standard for a Spring Boot application, and it's often referred to as the **"Spring Boot Bootstrap"** because it initializes the Spring context and enables all auto-configured components.

---

#### **Service code:
```java
package _7.project1.Service;

import _7.project1.Entity.Employee;
import _7.project1.Repository.CallingTrackerRepository;
import _7.project1.Repository.EmployeeRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.Optional;

@Service
public class EmployeeService {

    @Autowired
    private EmployeeRepository employeeRepository;

    @Autowired
    private CallingTrackerRepository callingTrackerRepository;


    public Employee addEmployee(Employee employee){
        Optional<Employee> existingEmployee = employeeRepository.findByUserName(employee.getUserName());
        if (existingEmployee.isPresent()){

            Employee updatedEmployee = existingEmployee.get();
            updatedEmployee.setEmployeeName(employee.getEmployeeName());
            updatedEmployee.setUserName(employee.getUserName());
            updatedEmployee.setDateOfBirth(employee.getDateOfBirth());
            updatedEmployee.setDateOfJoining(employee.getDateOfJoining());
            updatedEmployee.setDesignation(employee.getDesignation());
            updatedEmployee.setDepartment(employee.getDepartment());
            updatedEmployee.setOfficialMail(employee.getOfficialMail());
            updatedEmployee.setEmployeeEmail(employee.getEmployeeEmail());
            updatedEmployee.setOfficialContactNumber(employee.getOfficialContactNumber());
            updatedEmployee.setAlternateContactNo(employee.getAlternateContactNo());
            updatedEmployee.setGender(employee.getGender());
            updatedEmployee.setCompanyMobileNumber(employee.getCompanyMobileNumber());
            updatedEmployee.setWhatsAppNumber(employee.getWhatsAppNumber());
            updatedEmployee.setEmergencyContactNumber(employee.getEmergencyContactNumber());
            updatedEmployee.setEmergencyPersonRelation(employee.getEmergencyPersonRelation());
            updatedEmployee.setEmployeePresentAddress(employee.getEmployeePresentAddress());
            updatedEmployee.setEmployeeExperience(employee.getEmployeeExperience());
            updatedEmployee.setPerks(employee.getPerks());
            updatedEmployee.setMaritalStatus(employee.getMaritalStatus());
            updatedEmployee.setAnniversaryDate(employee.getAnniversaryDate());
            updatedEmployee.setTshirtSize(employee.getTshirtSize());
            updatedEmployee.setLastCompany(employee.getLastCompany());
            updatedEmployee.setWorkLocation(employee.getWorkLocation());
            updatedEmployee.setEntrySource(employee.getEntrySource());
            updatedEmployee.setEmployeeStatus(employee.getEmployeeStatus());
            updatedEmployee.setLastWorkingDate(employee.getLastWorkingDate());
            updatedEmployee.setReasonForLeaving(employee.getReasonForLeaving());
            updatedEmployee.setInductionYesOrNo(employee.getInductionYesOrNo());
            updatedEmployee.setInductionComment(employee.getInductionComment());
            updatedEmployee.setTrainingSource(employee.getTrainingSource());
            updatedEmployee.setTrainingCompletedYesOrNo(employee.getTrainingCompletedYesOrNo());
            updatedEmployee.setTrainingTakenCount(employee.getTrainingTakenCount());
            updatedEmployee.setRoundsOfInterview(employee.getRoundsOfInterview());
            updatedEmployee.setInterviewTakenPerson(employee.getInterviewTakenPerson());
            updatedEmployee.setWarningComments(employee.getWarningComments());
            updatedEmployee.setPerformanceIndicator(employee.getPerformanceIndicator());
            updatedEmployee.setTeamLeaderMsg(employee.getTeamLeaderMsg());
            updatedEmployee.setEditDeleteAuthority(employee.getEditDeleteAuthority());
            updatedEmployee.setLinkedInURl(employee.getLinkedInURl());
            updatedEmployee.setFaceBookURL(employee.getFaceBookURL());
            updatedEmployee.setTwitterURl(employee.getTwitterURl());
            updatedEmployee.setEmployeeAddress(employee.getEmployeeAddress());
            updatedEmployee.setBloodGroup(employee.getBloodGroup());
            updatedEmployee.setAadhaarNo(employee.getAadhaarNo());
            updatedEmployee.setPanNo(employee.getPanNo());
            updatedEmployee.setEducationalQualification(employee.getEducationalQualification());
            updatedEmployee.setOfferedSalary(employee.getOfferedSalary());
            updatedEmployee.setJobRole(employee.getJobRole());
            updatedEmployee.setProfessionalPtNo(employee.getProfessionalPtNo());
            updatedEmployee.setEsIcNo(employee.getEsIcNo());
            updatedEmployee.setPfNo(employee.getPfNo());
            updatedEmployee.setInsuranceNumber(employee.getInsuranceNumber());
            updatedEmployee.setReportingMangerName(employee.getReportingMangerName());
            updatedEmployee.setReportingMangerDesignation(employee.getReportingMangerDesignation());
            updatedEmployee.setEmployeePassword(employee.getEmployeePassword());
            updatedEmployee.setConfirmPassword(employee.getConfirmPassword());
            updatedEmployee.setProfileImage(employee.getProfileImage());
            updatedEmployee.setDocument(employee.getDocument());
            updatedEmployee.setResumeFile(employee.getResumeFile());
            updatedEmployee.setOldTeamLeaderId(employee.getOldTeamLeaderId());
            updatedEmployee.setLoginStatus(employee.getLoginStatus());

            return employeeRepository.save(updatedEmployee);
        } else {
            return employeeRepository.save(employee);
        }
    }

    public Optional<Employee> getEmployeeByUserName(String username){
        return employeeRepository.findByUserName(username);
    }
}

```

#### **Explanation of code:
## EmployeeService Class

This code defines the `EmployeeService` class, which is part of a Spring Boot application. The purpose of this service is to manage `Employee` entities in the system. It handles adding and updating employee information and interacts with two repositories: `EmployeeRepository` (for managing employee data) and `CallingTrackerRepository` (although the latter is not used in this code).

#### 1. Annotations

#### `@Service`
- **Purpose**: This annotation marks the class as a service component in Spring's service layer.
- **Functionality**: By annotating the `EmployeeService` class with `@Service`, Spring will automatically register it as a Spring Bean in the application context, meaning it will be automatically managed by Spring's Dependency Injection (DI) container.

#### `@Autowired`
- **Purpose**: The `@Autowired` annotation is used to automatically inject dependencies.
- **Functionality**: In this case, Spring will automatically provide instances of the `EmployeeRepository` and `CallingTrackerRepository` beans into the `EmployeeService` class. These repositories will be used to interact with the database.

#### 2. Instance Variables

#### `private EmployeeRepository employeeRepository`
- **Purpose**: This is the repository interface for `Employee` entities. `EmployeeRepository` extends `JpaRepository`, so it provides basic CRUD operations such as `save()`, `findById()`, and `findByUserName()` out of the box, without the need to write custom SQL queries.

#### `private CallingTrackerRepository callingTrackerRepository`
- **Purpose**: This is another repository that is injected, but it is not used in the current code. It might be useful for future features that track calls or actions related to employees (e.g., tracking communication or interactions).

#### 3. The `addEmployee` Method

This is the primary method in the service. It either updates an existing employee or adds a new one based on whether an employee with the given username already exists.

#### Method Signature:
```java
public Employee addEmployee(Employee employee)

```
#### Purpose:
This method takes an Employee object as input and returns the saved Employee object. It handles both creating new employees and updating existing ones.

#### Logic:
#### Step 1. **Check if the Employee Already Exists:**
```java
Optional<Employee> existingEmployee = employeeRepository.findByUserName(employee.getUserName());

```
This line checks if an employee with the same `userName` already exists in the database by calling the `findByUserName` method in the `EmployeeRepository`. This method returns an `Optional<Employee>`, which may contain an `Employee` if one is found, or be empty if no employee with the provided username exists.

#### Step 2: If Employee Exists, Update Their Details
```java
if (existingEmployee.isPresent()) {
    Employee updatedEmployee = existingEmployee.get();
    // Set all employee fields from the incoming employee object
    updatedEmployee.setEmployeeName(employee.getEmployeeName());
    updatedEmployee.setUserName(employee.getUserName());
    // ... (set all other fields)
    return employeeRepository.save(updatedEmployee);
}

```
If an employee with the given username exists, we retrieve the existing employee (`existingEmployee.get()`).  
Then, we update each field of the existing employee using the values from the `employee` object passed to the method. This allows us to modify specific details (like name, email, designation, etc.) without replacing the entire record.  
After updating all fields, the method saves the updated employee back into the database using `employeeRepository.save(updatedEmployee)`. This persists the changes to the database.

#### Step 3: If Employee Does Not Exist, Save as a New Employee
```java
else {
    return employeeRepository.save(employee);
}

```
If no existing employee is found (i.e., the `existingEmployee` is empty), this block of code is executed. In this case, the method directly saves the new `Employee` object to the database using `employeeRepository.save(employee)`.

The `save()` method is provided by `JpaRepository` and performs the persistence operation, either inserting a new record or updating an existing one depending on the state of the `Employee` entity.

#### 4. The getEmployeeByUserName Method:
```java
public Optional<Employee> getEmployeeByUserName(String username)

```   
#### Purpose:
This method retrieves an `Employee` from the database by their username.  
It uses the `findByUserName` method in the `EmployeeRepository` to fetch the employee. The return type is an `Optional<Employee>`, which is a safe way of handling potential null values. If no employee with the provided username exists, it returns `Optional.empty()`.

#### Key Points:

1. **Repository Layer**:  
   The `EmployeeRepository` is a Spring Data JPA repository that provides methods like `findByUserName()` and `save()`, allowing the service to interact with the database without writing custom SQL queries.

2. **Updating an Employee**:  
   The method provides a detailed way to update an employee’s record. Instead of replacing the entire entity, it updates individual fields of the existing employee. This gives more control and flexibility to update specific fields without modifying everything.

3. **Use of Optional**:  
   The `Optional<Employee>` return type from `findByUserName` is a good practice because it avoids the potential for `NullPointerExceptions`. It forces the caller to handle the case where the employee may not exist (e.g., `if (existingEmployee.isPresent())`).

4. **The Role of CallingTrackerRepository**:  
   Although `CallingTrackerRepository` is injected, it is not used in this particular method. It might be used elsewhere in the application to track employee-related calls or actions.

5. **Spring's Dependency Injection**:  
   The `@Autowired` annotations indicate that Spring will manage the lifecycle of `EmployeeRepository` and `CallingTrackerRepository`, and automatically inject them into the `EmployeeService` class.

#### Summary:
- The `EmployeeService` class is a Spring service component that handles the logic for adding or updating employee records.
- The `addEmployee` method checks whether an employee with a specific username exists and either updates the existing record or creates a new one.
- The `getEmployeeByUserName` method allows fetching an employee by their username.
- This class acts as an intermediary between the controller layer (which handles HTTP requests) and the repository layer (which interacts with the database).

---

#### **Controller Class code
```java
package _7.project1.Controller;

import _7.project1.Dto.CallingTrackerLineUpDto;
import _7.project1.Entity.Employee;
import _7.project1.Service.CallingTrackerService;
import _7.project1.Service.EmployeeService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import java.time.LocalDate;

@RestController
@RequestMapping("/api/employee")
public class EmployeeController {

    @Autowired
    private EmployeeService employeeService;

    @Autowired
    private CallingTrackerService callingTrackerService;

    @PostMapping("/add")
    public ResponseEntity<Employee> addEmployee( @RequestBody Employee employee){
        try{
            return new ResponseEntity<>(employeeService.addEmployee(employee), HttpStatus.OK);

        }catch (RuntimeException e){
            return new ResponseEntity<>(null, HttpStatus.BAD_REQUEST);
        }
    }

    @PostMapping("/add-with-lineup/{employee_Id}")
    public ResponseEntity<String> addCallingTrackerWithLineUp(@RequestBody CallingTrackerLineUpDto dto,@PathVariable Long employee_Id) {
        CallingTrackerLineUpDto dto2 = new CallingTrackerLineUpDto();
        LocalDate  date = dto2.getDate();
        System.out.println(date+ "date");
        callingTrackerService.saveCallingTrackerWithLineUp(dto, employee_Id);
        return ResponseEntity.ok("CallingTracker and LineUp saved successfully!");
    }
}

```

#### **Explanation of code
#### This code defines a Spring Boot `EmployeeController` class that handles HTTP requests related to employee and calling tracker data. It serves as an interface between the frontend (or client) and the service layer, allowing clients to add employees and calling tracker data.

#### Let’s break down the code in detail:

#### Code Breakdown

#### 1. Annotations

- **@RestController**
  - **Purpose**:  
    The `@RestController` annotation is a specialized version of `@Controller`. It is used in Spring MVC to create RESTful web services. It combines `@Controller` and `@ResponseBody`, meaning every method in this controller will return the response body directly, typically in JSON or XML format.
  - **Functionality**:  
    This class is a controller in a REST API, and the return values of methods will automatically be converted to HTTP responses (e.g., JSON).
  
- **@RequestMapping("/api/employee")**
  - **Purpose**:  
    The `@RequestMapping` annotation is used to map HTTP requests to handler methods of MVC and REST controllers. In this case, the base URL for all routes in this controller is `/api/employee`.
  - **Functionality**:  
    All endpoints in this controller will be prefixed with `/api/employee`.

- **@Autowired**
  - **Purpose**:  
    The `@Autowired` annotation is used for dependency injection in Spring. It automatically injects the necessary service beans into this controller.

- **@PostMapping**
  - **Purpose**:  
    The `@PostMapping` annotation is used to handle HTTP POST requests. It is shorthand for `@RequestMapping(method = RequestMethod.POST)`.
  - **Functionality**:  
    In this case, the controller has two POST methods for adding employees and calling tracker data.

- **@RequestBody**
  - **Purpose**:  
    The `@RequestBody` annotation binds the HTTP request body to a method parameter. In this code, it is used to deserialize the incoming JSON payload into a Java object (`Employee` or `CallingTrackerLineUpDto`).

- **@PathVariable**
  - **Purpose**:  
    The `@PathVariable` annotation is used to bind the value of a URI template variable to a method parameter. In this case, the employee ID is extracted from the URL and passed to the method.

#### 2. Instance Variables

- **private EmployeeService employeeService**
  - **Purpose**:  
    This is the service layer that handles business logic for employee-related operations (e.g., adding and updating employees). It is injected into the controller using `@Autowired`.

- **private CallingTrackerService callingTrackerService**
  - **Purpose**:  
    This is another service layer that handles business logic related to calling tracker operations. It is also injected into the controller using `@Autowired`.

#### 3. Methods

- **addEmployee Method**
```java
@PostMapping("/add")
public ResponseEntity<Employee> addEmployee(@RequestBody Employee employee) {
    try {
        return new ResponseEntity<>(employeeService.addEmployee(employee), HttpStatus.OK);
    } catch (RuntimeException e) {
        return new ResponseEntity<>(null, HttpStatus.BAD_REQUEST);
    }
}

```
#### Purpose:
This method is responsible for adding a new employee to the system. It is mapped to the URL `/api/employee/add`.

#### Request:
The method expects an `Employee` object in the HTTP request body (annotated with `@RequestBody`).

#### Logic:
- The employee data is passed to the `addEmployee` method of the `EmployeeService` class.
- If the employee is successfully added, the method returns a `ResponseEntity` with a `HttpStatus.OK` (200) status and the employee data.
- If any error occurs (e.g., a `RuntimeException`), it returns a `ResponseEntity` with a `HttpStatus.BAD_REQUEST` (400) status.

#### Return:
A `ResponseEntity<Employee>` is returned, containing the employee data and an HTTP status code indicating whether the operation was successful.

#### `addCallingTrackerWithLineUp` Method
```java
@PostMapping("/add-with-lineup/{employee_Id}")
public ResponseEntity<String> addCallingTrackerWithLineUp(@RequestBody CallingTrackerLineUpDto dto, @PathVariable Long employee_Id) {
    CallingTrackerLineUpDto dto2 = new CallingTrackerLineUpDto();
    LocalDate date = dto2.getDate();
    System.out.println(date + " date");
    callingTrackerService.saveCallingTrackerWithLineUp(dto, employee_Id);
    return ResponseEntity.ok("CallingTracker and LineUp saved successfully!");
}

```
#### Purpose:
This method is responsible for adding a calling tracker and a lineup for an employee. It is mapped to the URL `/api/employee/add-with-lineup/{employee_Id}`.

#### Request:
- The method expects a `CallingTrackerLineUpDto` object in the request body (annotated with `@RequestBody`).
- The `employee_Id` is extracted from the URL path (annotated with `@PathVariable`).

#### Logic:
- First, a new `CallingTrackerLineUpDto` object is created, and the date is extracted from it.
- The date is printed to the console for logging purposes.
- The method then calls the `saveCallingTrackerWithLineUp` method of the `CallingTrackerService` to save the calling tracker and lineup data for the employee.

#### Return:
- The method returns a `ResponseEntity<String>` with a success message ("CallingTracker and LineUp saved successfully!") and a `HttpStatus.OK` (200) status.

---

#### 4. Exception Handling
- In the `addEmployee` method, if a `RuntimeException` occurs while adding the employee, it is caught in the catch block, and a response with `HttpStatus.BAD_REQUEST` (400) is returned. This is basic error handling to inform the client that there was an issue with the request.

---

#### Summary of Endpoints

- **POST /api/employee/add**:
  - Adds a new employee.
  - Accepts an `Employee` object in the request body.

- **POST /api/employee/add-with-lineup/{employee_Id}**:
  - Adds a calling tracker and lineup for an existing employee.
  - Accepts a `CallingTrackerLineUpDto` object in the request body and the `employee_Id` in the URL path.

---

#### Key Points:
- `@RequestBody` is used for parsing the request body into Java objects.
- `@PathVariable` allows extracting values from the URL path.
- The controller communicates with the service layer (`EmployeeService` and `CallingTrackerService`) to perform business logic.
- Responses are wrapped in `ResponseEntity`, which allows custom HTTP status codes and headers.
- This controller serves as the entry point for client requests related to employee and calling tracker data.
